'use client';

import { useState, useEffect, useRef } from 'react';
import type { MiniGameComponentProps } from '@/app/types/game';

/**
 * ã‚¹ãƒ­ãƒƒãƒˆãƒã‚·ãƒ³ã‚²ãƒ¼ãƒ 
 * ç›®æŠ¼ã—ã§3ã¤ã®çµµæŸ„ã‚’æƒãˆã‚‹
 */
export default function SlotMachine({ onSuccess, onFailure }: MiniGameComponentProps) {
  const [slots, setSlots] = useState(["ğŸ’", "ğŸ‹", "ğŸŠ"]);
  const [isSpinning, setIsSpinning] = useState([false, false, false]); // åˆæœŸçŠ¶æ…‹ã‚’åœæ­¢ã«å¤‰æ›´
  const [result, setResult] = useState<string | null>(null);

  const symbols = ["ğŸ’", "ğŸ‹", "ğŸŠ", "â­", "ğŸ‡"];

  const intervalsRef = useRef<(number | NodeJS.Timeout)[]>([]); // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«IDã‚’ä¿æŒã™ã‚‹ref
  const latestSlotsRef = useRef(slots); // æœ€æ–°ã®ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹ref
  const timeoutRef = useRef<number | NodeJS.Timeout | null>(null); // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆIDã‚’ä¿æŒã™ã‚‹ref

  const stopSlot = (index: number) => {
    // æŒ‡å®šã•ã‚ŒãŸã‚¹ãƒ­ãƒƒãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
    const id = intervalsRef.current[index];
    if (id) clearInterval(id as any);
    delete intervalsRef.current[index]; // ãƒªã‚»ãƒƒãƒˆ

    setIsSpinning((prev) => {
      const newSpinning = [...prev];
      newSpinning[index] = false;
      return newSpinning;
    });

    // å…¨ã‚¹ãƒ­ãƒƒãƒˆãŒåœæ­¢ã—ã¦ã„ã‚‹å ´åˆã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚‚ã‚¯ãƒªã‚¢
    if (isSpinning.every((spinning) => !spinning)) {
      if (timeoutRef.current) clearTimeout(timeoutRef.current as any);
    }
  };

  const spinSlots = () => {
    if (isSpinning.some((spinning) => spinning)) return; // ãƒ€ãƒ–ãƒ«ã‚¹ãƒ”ãƒ³ã‚’é˜²æ­¢

    setResult(null);
    setIsSpinning([true, true, true]); // å„ã‚¹ãƒ­ãƒƒãƒˆã‚’å›è»¢çŠ¶æ…‹ã«è¨­å®š

    // æ—¢å­˜ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
    intervalsRef.current.forEach((interval) => clearInterval(interval as any));
    intervalsRef.current = [] as any; // ãƒªã‚»ãƒƒãƒˆ

    // å›ºå®šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ã‚’ä½¿ç”¨ã—ã¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ä½œæˆ
    [0, 1, 2].forEach((index) => {
      const intervalId = setInterval(() => {
        setSlots((prev) => {
          const newSlots = [...prev];
          newSlots[index] = getRandomSymbol();
          latestSlotsRef.current = newSlots; // æœ€æ–°ã®ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã‚’æ›´æ–°
          return newSlots;
        });
      }, 300); // ã‚¹ãƒ­ãƒƒãƒˆã®å›è»¢é€Ÿåº¦ã‚’é…ãã™ã‚‹
      intervalsRef.current.push(intervalId as any); // ãƒ—ãƒƒã‚·ãƒ¥
    });

    timeoutRef.current = setTimeout(() => {
      // ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
      intervalsRef.current.forEach((interval) => clearInterval(interval as any));
      intervalsRef.current = [] as any; // ãƒªã‚»ãƒƒãƒˆ

      setIsSpinning([false, false, false]); // å…¨ã‚¹ãƒ­ãƒƒãƒˆã‚’åœæ­¢çŠ¶æ…‹ã«è¨­å®š

      const finalSlots = latestSlotsRef.current; // æœ€æ–°ã®ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã‚’å–å¾—
      if (finalSlots[0] === finalSlots[1] && finalSlots[1] === finalSlots[2]) {
        setResult('win');
        onSuccess();
      } else {
        setResult('lose');
        onFailure?.();
      }
    }, 3000) as any;
  };

  useEffect(() => {
    return () => {
      intervalsRef.current.forEach((interval) => {
        if (interval) clearInterval(interval as any);
      });
      if (timeoutRef.current) clearTimeout(timeoutRef.current as any);
    };
  }, []);

  const getRandomSymbol = () => {
    return symbols[Math.floor(Math.random() * symbols.length)];
  };

  return (
    <div className="flex flex-col items-center gap-6 p-6">
      <h2 className="text-2xl font-bold">ã‚¹ãƒ­ãƒƒãƒˆãƒã‚·ãƒ³</h2>
      <p className="text-sm text-gray-400">ç›®æŠ¼ã—ã§3ã¤ã®çµµæŸ„ã‚’æƒãˆã¦ãã ã•ã„ï¼</p>

      <div className="flex gap-4 text-4xl">
        {slots.map((slot, index) => (
          <div
            key={index}
            className="w-16 h-16 flex items-center justify-center border-2 border-gray-500 bg-gray-800 text-white"
          >
            {slot}
          </div>
        ))}
      </div>

      <div className="flex gap-4">
        {isSpinning.map((spinning, index) => (
          <button
            key={index}
            onClick={() => stopSlot(index)}
            disabled={!spinning}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-500"
          >
            {spinning ? `ã‚¹ãƒˆãƒƒãƒ— ${index + 1}` : 'åœæ­¢ä¸­'}
          </button>
        ))}
      </div>

      <button
        onClick={spinSlots}
        className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
      >
        ã‚¹ãƒ­ãƒƒãƒˆå›è»¢
      </button>

      {result && (
        <div
          className={`text-xl font-bold mt-4 ${
            result === 'win' ? 'text-green-500' : 'text-red-500'
          }`}
        >
          {result === 'win' ? 'ãŠã‚ã§ã¨ã†ï¼æƒã„ã¾ã—ãŸï¼' : 'æ®‹å¿µï¼ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ï¼'}
        </div>
      )}
    </div>
  );
}
